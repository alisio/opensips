#
# $Id$
#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      http://www.opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#


####### Global Parameters #########

log_level=3
log_stderror=no
log_facility=LOG_LOCAL<%= @syslog_local %>

children=4


/* uncomment the next line to enable the auto temporary blacklisting of
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns
   lookup failures (default disabled) */
#dns_try_ipv6=yes

/* comment the next line to enable the auto discovery of local aliases
   based on revers DNS on IPs */
auto_aliases=no

<%
if @proxy_eth_interface.count(',') > 0 then
    @proxy_eth_interface.split(',').each do |int|
        if has_variable?("ipaddress_#{int}") then
            -%>listen=<%= @proxy_transport %>:<%= scope.lookupvar("ipaddress_#{int}") %>:<%= @proxy_port %>
<%
        end
    end
else
    interface = @proxy_eth_interface
    if has_variable?("ipaddress_#{interface}") then
        -%>listen=<%= @proxy_transport %>:<%= scope.lookupvar("ipaddress_#{interface}") %>:<%= @proxy_port %><%
    end
end
-%>

####### Modules Section ########

#set module path
mpath="/lib64/opensips/modules/"

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Text heandling
loadmodule "textops.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 0)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)


#### URI module
loadmodule "uri.so"
modparam("uri", "use_uri_table", 0)

#### MYSQL module
loadmodule "db_mysql.so"

#### HTTPD module
loadmodule "httpd.so"
modparam("httpd", "port", <%= @opensips_http_mi_port %>)
loadmodule "mi_json.so"

#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "db_mode",   2)
modparam("usrloc", "db_url",
	"mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>") # CUSTOMIZE ME


#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")

/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)



#### AUTHentication modules
loadmodule "auth.so"
loadmodule "auth_db.so"
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db|uri", "db_url",
	"mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>") # CUSTOMIZE ME
modparam("auth_db", "load_credentials", "")

#### DOMAIN module
loadmodule "domain.so"
modparam("domain", "db_url",
	"mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>") # CUSTOMIZE ME
modparam("domain", "db_mode", 1)   # Use caching
modparam("auth_db|usrloc|uri", "use_domain", 1)

#### ALIAS module
loadmodule "alias_db.so"
modparam("alias_db", "db_url",
	"mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>") # CUSTOMIZE ME

loadmodule "cachedb_local.so"

modparam("auth","username_spec","$avp(userspec)")
modparam("auth","password_spec","$avp(passwd)")
modparam("auth","calculate_ha1",1)

loadmodule "permissions.so"
loadmodule "group.so"

# ----- permissions params ----
modparam("permissions", "db_url","mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>")
modparam("group", "db_url","mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>")

loadmodule "drouting.so"

# ----- drouting params -----
modparam("drouting", "use_domain", 0)
modparam("drouting","db_url", "mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>")

# ----- tm params -----
modparam("tm", "fr_timeout", 3)
modparam("tm", "fr_inv_timeout", 20)

loadmodule "avpops.so"
loadmodule "dialplan.so"

#------ avpops params -----
modparam("avpops", "db_url", "mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>")
modparam("avpops", "avp_table", "usr_preferences")

#------ load the dpid field to a pseudo-variable $avp(dpid) ------
modparam("auth_db", "load_credentials", "$avp(rpid)=rpid ;$avp(dpid)= dpid; $avp(passwd)=password")
modparam("dialplan", "db_url","mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>")
## attribute of the matched line will be store in the $avp(dest)

loadmodule "<%= @mediaproxy_type %>.so"
modparam("<%= @mediaproxy_type %>", "<%= @mediaproxy_type %>_sock", "<%= @mediaproxy_ctrl_socket %>")


loadmodule "nathelper.so"
modparam("usrloc","nat_bflag","NAT_FLAG")

# Nathelper parameters
modparam("registrar","received_avp", "$avp(42)")
modparam("nathelper","received_avp", "$avp(42)")
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", "SIPPING_FLAG")
modparam("nathelper", "sipping_from", "sip:pinger@192.168.0.17")

loadmodule "dialog.so"
modparam("dialog", "profiles_with_value", "caller ; domain")
modparam("dialog", "profiles_no_value", "progress ; active")
modparam("dialog", "db_mode", 2)
modparam("dialog", "db_url", "mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>")

##### ACCounting module
loadmodule "acc.so"
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 0)
/* by default we do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)

modparam("acc", "db_url", "mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>")
#modparam("acc", "multi_leg_info", "caller_id=$avp(caller); callee_id=$avp(callee)")
#modparam("acc", "db_extra", "leg_type=$avp(legtype)")
#modparam("acc", "db_extra", "caller_id=$fU; callee_id=$rU;leg_type=$avp(legtype)")
modparam("acc", "extra_fields", "db: $fU->caller_id; $rU->callee_id; $avp(legtype)->leg_type")


### S1 ###
loadmodule "siptrace.so"
modparam("siptrace", "trace_id", "[1] uri=mysql://<%= @db_opensips_user %>:<%= @db_opensips_pw %>@<%= @db_server_ip %>/<%= @db_opensips_db %>;table=sip_trace;")
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "trace_local_ip", "<%= @proxy_ip %>:<%= @proxy_port %>")
### S1  ###


loadmodule "proto_udp.so"

####### Routing Logic ########

# main request routing logic

route{

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	## NAT Detection
	#
	force_rport();
	if (nat_uac_test("18")) {
		if ($rm=="REGISTER") {
			fix_nated_register();
		} else {
			fix_nated_contact();
		}
         	setflag(NAT_FLAG);
	}

	if (has_totag()) {
		# sequential request withing a dialog should
		# take the path determined by record-routing
		if (loose_route()) {


			if (is_method("BYE")) {
				do_accounting("log|db","failed");
			} else if (is_method("INVITE")) {
				# even if in most of the cases is useless, do RR for
				# re-INVITEs alos, as some buggy clients do change route set
				# during the dialog.
				record_route();
			}



			# route it out to whatever destination was set by loose_route()
			# in $du (destination URI).
			route(relay);
		} else {

			if ( is_method("ACK") ) {
				if ( t_check_trans() ) {
					# non loose-route, but stateful ACK; must be an ACK after
					# a 487 or e.g. 404 from upstream server
					t_relay();
					exit;
				} else {
					# ACK without matching transaction ->
					# ignore and discard
					exit;
				}
			}
			sl_send_reply("404","Not here");
		}
		exit;
	}

	$avp(caller)=$fU;
	$avp(callee)=$rU;

	#Create dialog for initial requests
	#This will allow ACC to compute duration and setup time
	if(is_method("INVITE")) create_dialog();

	### S2 ###
	if(is_method("INVITE")) sip_trace("1", "d", "$fU");
	### S2 ###

	# CANCEL processing
	if (is_method("CANCEL"))
	{
		if (t_check_trans())
			t_relay();
		exit;
	}

	t_check_trans();


	if ( (!is_method("REGISTER") && $si!="<%= @proxy_ip %>" ) ) {
		if(is_from_local())
		{

			# authenticate if from local subscriber
			# authenticate all initial non-REGISTER request that pretend to be
			# generated by local subscriber (domain from FROM URI is local)
			if(!check_source_address("0")){
				if (!proxy_authorize("", "subscriber")) {
					proxy_challenge("", "0");
					exit;
			   	}
				if (!db_check_from()) {
					sl_send_reply("403","Forbidden auth ID");
					exit;
				}
			}

			consume_credentials();
			# caller authenticated

		} else {
			# if caller is not local, then called number must be local

			if (!is_myself("$rd")) {
				send_reply("403","Rely forbidden");
				exit;
			}
		}

	}

	# preloaded route checking
	if (loose_route()) {
		xlog("L_ERR",
		"Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
		if (!is_method("ACK"))
			sl_send_reply("403","Preload Route denied");
		exit;
	}

	# record routing
	if (!is_method("REGISTER|MESSAGE"))
		record_route();

	if (!is_uri_host_local()) {
		append_hf("P-hint: outbound\r\n");
		route(relay);
	}

	# requests for my domain

	if (is_method("PUBLISH|SUBSCRIBE"))
	{
		sl_send_reply("503", "Service Unavailable");
		exit;
	}

	if (is_method("REGISTER"))
	{
		### Caching for registration passwords ###
		# do we have the password cached ?
		if(cache_fetch("local","passwd_$tu",$avp(passwd))) {
		        $avp(userspec) = $tU;
		        xlog("SCRIPT: stored password is $avp(passwd)\n");
		        # perform auth from variables
		        # $avp(userspec) contains the username
		        # $avp(passwd) contains the password
		        if (!pv_www_authorize("")) {
	                	# authentication failed -> do challenge
		                www_challenge("", "0");
		                exit;
	        	};
		} else {
		        # perform DB authentication ->
		        # password will be loaded from DB automatically
		        if (!www_authorize("", "subscriber")) {
				# authentication failed -> do challenge
		                 www_challenge("", "0");
		                 exit;
			};
		        # after DB authentication, the password is available
		        # in $avp(passwd) because of the "load_credentials"
		        # module parameter.
		        xlog("SCRIPT: storing password <$avp(passwd)>\n");
		        # use a 20 minutes lifetime for the password;
		        # after that, it will erased from cache and we do
		        # db authentication again (refresh the passwd from DB)
		        cache_store("local","passwd_$tu","$avp(passwd)",1200);
		}

		# authenticate the REGISTER requests
		#if (!www_authorize("", "subscriber"))
		#{
		#	www_challenge("", "0");
		#	exit;
		#}

		if (!db_check_to())
		{
			sl_send_reply("403","Forbidden auth ID");
			exit;
		}

		if (   0 ) setflag(TCP_PERSISTENT);

		if (isflagset(NAT_FLAG)) {
			setbflag(NAT_BFLAG);
			setbflag(SIPPING_FLAG);
		};

		if (!save("location"))
			sl_reply_error();

		exit;
	}

	if ($rU==NULL) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	if($rU=~"^[2-9][0-9]{6}$"){
		# usuario discou somente 7 digitos. O numero sera normalizado y6
		if(db_is_user_in("credentials","local")){
			prefix("1305");
			route(4);
			exit;
		} else {
			sl_send_reply("403","No Permission for local calls - sem permissao para chamadas locais");
			exit;
		}
	}
	if($ru=~"^sip:1[0-9][0-9][0-9][2-9][0-9]{6}@"){
		if(db_is_user_in("credentials","ld")){
			route(4);
			exit;
		} else {
			sl_send_reply("403","No Permission for long distance calls - sem permissao para chamadas DDD");
		}
	}
	#Chamadas internacionais usando 011+e164
	if ($ru=~"^sip:011[0-9]*@") {
		if (db_is_user_in("credentials","int")) {
			strip(3);
			route(4);
			exit;
		} else {
			sl_send_reply("403", "No permissions for international calls");
			exit;
		}
	}

	if(avp_db_load("$ru","$avp(callfwd)")) {
	     $avp(caller)=$rU;
	     $ru=$avp(callfwd);
	     $avp(callee)=$rU;
	     xlog("forwarded to: $avp(callfwd)");
	}

	# Dial plan processing
	if( !is_avp_set("$avp(dpid)") ) {
		$avp(dpid)=0;
	}

	if(!dp_translate("$avp(dpid)","$ruri.user/$ruri.user","$avp(dest)")) {
		sl_send_reply("420", "Invalid Extension");
		exit;
	}
	xlog("Dialplan: Subscriber.s dpid: $(avp(dpid))");
	xlog("Dialplan: Destination: $avp(dest)");

	if ($avp(dest)=="3") {
		#Route to usrloc
		route(usrloc);
	}

	if ($avp(dest)=="4") {
		#route to drouting
		route(pstn);
	}

	if ($avp(dest)=="5") {
		#route to media server
		route(media);
	}
	sl_send_reply("420", "Invalid Extension");
	exit;

	alias_db_lookup("dbaliases");

	# do lookup with method filtering
	if (!lookup("location","m")) {
		if (!db_does_uri_exist()) {
			send_reply("420","Bad Extension");
			exit;
		}

		t_newtran();
		t_reply("404", "Not Found");
		exit;
	}

	# when routing via usrloc, log the missed calls also
	setflag(ACC_MISSED);
	route(relay);
}


route[pstn] {
    xlog("routed using drouting");
    # routing to the pstn
    if(!do_routing("0")) {
	     sl_send_reply("500", "No routes available");
	     exit;
    }
    ## for INVITEs enable some additional helper routes
    if (is_method("INVITE")) {
		t_on_branch("per_branch_ops");
		t_on_reply("handle_nat");
		t_on_failure("gateway_fail");
    }

    # for INVITEs enable some additional helper routes
    if (subst_uri('/(sip:.*);nat=yes/\1/')){
   		setbflag(NAT_BFLAG);
    };

    if (isflagset(NAT_FLAG)||isbflagset(NAT_BFLAG)) {
           route(mediarelay);
    };

    #account only pstn calls
    $avp(legtype)="pstn";
    do_accounting("log|db","cdr|failed");

    if (!t_relay()) {
		sl_reply_error();
    }
    exit;
}

route[4] {
  rewritehostport("<%= @opensips_defaultgw_hostport %>:<%= @proxy_port %>");
  xlog("Enviando chamada para rota 1");
  route(relay);
}

route[relay] {

	# for INVITEs enable some additional helper routes
	if (is_method("INVITE")) {
		t_on_branch("per_branch_ops");
		t_on_reply("handle_nat");
		t_on_failure("missed_call");
	}

	# for INVITEs enable some additional helper routes
	if (subst_uri('/(sip:.*);nat=yes/\1/')){
   		setbflag(NAT_BFLAG);
	};

	if (isflagset(NAT_FLAG)||isbflagset(NAT_BFLAG)) {
           route(mediarelay);
	};

	if (!t_relay()) {
		send_reply("500","Internal Error");
	};
	exit;
}


route[usrloc]{
	if (!lookup("location")) {
		switch ($retcode) {
			case -1:
			case -3:
				t_newtran();
				t_reply("404", "Not Found");
				exit;
			case -2:
				sl_send_reply("405", "Method Not Allowed");
				exit;
		}
	}
	# when routing via usrloc, log the missed calls also
	if(is_method("INVITE")) do_accounting("db","cdr|missed");
	route(relay);
}

route[media] {
	rewritehostport("192.168.11.137:5061");
	route(relay);
}



branch_route[per_branch_ops] {
	xlog("new branch at $ru\n");
}


onreply_route[handle_nat] {
    #-- On-replay block routing --
    #
		if($DLG_status!=NULL && is_method("INVITE")) {
			if($rs=~"18[0-9]") {
				set_dlg_profile("progress");
			} else {
				if(is_in_profile("progress")) unset_dlg_profile("progress");
			}
			if($rs=~"2[0-9][0-9]") {
				set_dlg_profile("active");
			} else {
				if(is_in_profile("active")) unset_dlg_profile("active");
			}
		}

		if(is_method("INVITE")) {
			#Active Call Counter
			$var(cactive)=0;
			#In Progress Call Counter
			$var(cprogress)=0;
			get_profile_size("active","$var(cactive)");
			get_profile_size("progress","$var(cprogress)");
			xlog("L_INFO","There are $var(cactive) active calls and $var(cprogress) calls in progress");
		}
    if ((isflagset(NAT_FLAG) || isbflagset(NAT_BFLAG)) && $rs=~"(183)|(2[0-9][0-9])"){
        if($avp(nat)=="normal") {
            if(has_body("application/sdp")) rtpproxy_answer();
        } else {
            if(has_body("application/sdp")) rtpproxy_offer();
        }
        append_hf("P-hint: onreply_route|force_rtp_proxy \r\n");
        search_append('Contact:.*sip:[^>[:cntrl:]]*', ';nat=yes');
    }

    if (isbflagset(NAT_BFLAG)) {
        append_hf("P-hint: Onreply-route - fixcontact \r\n");
        fix_nated_contact();
    }
    exit;
}

failure_route[missed_call] {
	if (t_was_cancelled()) {
		exit;
	}

	if (isbflagset(NAT_BFLAG) || isflagset(NAT_FLAG)) {
		rtpproxy_unforce();
	}

	# uncomment the following lines if you want to block client
	# redirect based on 3xx replies.
	##if (t_check_status("3[0-9][0-9]")) {
	##t_reply("404","Not found");
	##	exit;
	##}

	##--
	##-- If busy send to the e-mail server, prefix the "b"
	##-- character to indicate busy.
	##--
	if (t_check_status("486")) {
        	revert_uri();
	        prefix("b"); #This prefix is included to play the busy message
        	xlog("L_ERR","> 486 ruri=<$ru>");
	        route(media);
     		route(relay);
	        exit;
	}
	##--
	##-- If timeout (408) or unavailable temporarily (480),
	##-- prefix the uri with the "u"character to indicate
	##-- unanswered and send to the e-mail
	##-- sever
	##--
	if (t_check_status("408") || t_check_status("480")) {
		revert_uri();
		prefix("u");#This prefix is included to play the unanswered message
		xlog("L_ERR","> 480 ruri=<$ru>");
		route(media);
		route(relay);
		exit;
	}
}

failure_route[gateway_fail] {
	if (t_was_cancelled()) {
   		exit;
	}

	if (isbflagset(NAT_BFLAG) || isflagset(NAT_FLAG)) {
		rtpproxy_unforce();
	}

	xlog("failure route 2\n");
	if (t_check_status("(408)|(5[0-9][0-9])")){
	if (use_next_gw()) {
		    xlog ("next gateway $ru \n");
		    t_on_failure("gateway_fail");
		    t_relay();
   		    exit;
		}
	       t_reply("503", "Service not available, no more gateways");
          exit;
	}
}

route[mediarelay] {
    if (is_method("INVITE")) {
        if (has_body("application/sdp")) {
            if (rtpproxy_offer())
            $avp(nat)="normal";
        } else {
            $avp(nat)="sdkonack";
        }
    }
    if (is_method("ACK") && has_body("application/sdp"))
        rtpproxy_answer();

    if (is_method("BYE|CANCEL"))
        rtpproxy_unforce();

}
